import { PrismaClient } from '@prisma/client';
import { Server as SocketServer } from 'socket.io';

// Phase 2: Intelligence & Analysis
import { RequirementsAnalyzer } from '../analysis/requirementsAnalyzer';
import { DependencyResolver } from '../analysis/dependencyResolver';
import { ComplexityEstimator } from '../analysis/complexityEstimator';

// Phase 3: Frontend Generation
import { ComponentDecomposer } from '../generation/frontend/componentDecomposer';
import { SequentialComponentBuilder } from '../generation/frontend/sequentialComponentBuilder';
import { IntegrationPromptGenerator } from '../generation/frontend/integrationPromptGenerator';

// Phase 4: Backend Generation
import { APIEndpointDecomposer } from '../generation/backend/apiEndpointDecomposer';
import { MiddlewareChainBuilder } from '../generation/backend/middlewareChainBuilder';
import { DatabaseSchemaEvolution } from '../generation/backend/databaseSchemaEvolution';

// Phase 5: Validation & Correction
import { CodeValidator } from '../validation/outputValidator';
import { AdaptivePromptRefinement } from '../core/adaptivePromptRefinement';
import { SelfCorrectingLoop } from '../core/selfCorrectingLoop';
import { HumanInTheLoop } from '../core/humanInTheLoop';

// Phase 6: Deployment
import { DeploymentTaskDecomposer } from '../deployment/deploymentTaskDecomposer';
import { InfrastructureProvisioner } from '../deployment/infrastructureProvisioner';

// Phase 7: Modifications
import { ModificationRequestDecomposer } from '../modifications/modificationRequestDecomposer';
import { IncrementalUpdateGenerator } from '../modifications/incrementalUpdateGenerator';

// Phase 8: Meta-Learning
import { PromptPerformanceTracker } from '../meta-learning/promptPerformanceTracker';
import { PromptTemplateEvolution } from '../meta-learning/promptTemplateEvolution';
import { FewShotLearningDatabase } from '../meta-learning/fewShotLearningDatabase';

// Phase 9: Visualization
import { PromptChainVisualizer } from '../visualization/promptChainVisualizer';
import { ExplainabilityLayer } from '../visualization/explainabilityLayer';

// Core services
import { ModelService } from '../core/modelService';
import { TaskDecomposer } from '../core/taskDecomposer';
import { PromptChainOrchestrator } from '../core/promptChainOrchestrator';

/**
 * Main Takoss Orchestrator - Coordinates all 22 prompts into unified workflows
 * The central hub that manages the entire application generation lifecycle
 */

export interface TakossConfig {
  workingDirectory: string;
  apiKeys?: {
    claude?: string;
    openai?: string;
    railway?: string;
    vercel?: string;
    pinecone?: string;
  };
  database?: {
    url?: string;
  };
  socketIO?: SocketServer;
  enableMetaLearning?: boolean;
  enableVisualization?: boolean;
}

export interface ProjectGenerationRequest {
  projectName: string;
  description: string;
  requirements: string;
  targetPlatforms?: string[];
  deploymentPreferences?: {
    frontend?: 'vercel' | 'netlify' | 'docker';
    backend?: 'railway' | 'heroku' | 'docker';
    database?: 'postgresql' | 'mysql' | 'mongodb';
  };
}

export interface ProjectGenerationResult {
  success: boolean;
  projectId: string;
  artifacts: {
    frontend?: string[];
    backend?: string[];
    database?: string[];
    deployment?: string[];
  };
  deploymentUrls?: {
    frontend?: string;
    backend?: string;
  };
  visualizations?: {
    chainVisualization?: string;
    explanation?: string;
  };
  errors?: string[];
  warnings?: string[];
}

export class TakossOrchestrator {
  private prisma: PrismaClient;
  private config: TakossConfig;

  // Phase 2: Analysis
  private requirementsAnalyzer: RequirementsAnalyzer;
  private dependencyResolver: DependencyResolver;
  private complexityEstimator: ComplexityEstimator;

  // Phase 3: Frontend
  private componentDecomposer: ComponentDecomposer;
  private componentBuilder: SequentialComponentBuilder;
  private integrationGenerator: IntegrationPromptGenerator;

  // Phase 4: Backend
  private apiDecomposer: APIEndpointDecomposer;
  private middlewareBuilder: MiddlewareChainBuilder;
  private schemaEvolution: DatabaseSchemaEvolution;

  // Phase 5: Validation
  private validator: CodeValidator;
  private adaptiveRefinement: AdaptivePromptRefinement;
  private selfCorrectingLoop: SelfCorrectingLoop;
  private humanInTheLoop?: HumanInTheLoop;

  // Phase 6: Deployment
  private deploymentDecomposer: DeploymentTaskDecomposer;
  private infrastructureProvisioner: InfrastructureProvisioner;

  // Phase 7: Modifications
  private modificationDecomposer: ModificationRequestDecomposer;
  private updateGenerator: IncrementalUpdateGenerator;

  // Phase 8: Meta-Learning
  private performanceTracker?: PromptPerformanceTracker;
  private templateEvolution?: PromptTemplateEvolution;
  private fewShotDB?: FewShotLearningDatabase;

  // Phase 9: Visualization
  private visualizer?: PromptChainVisualizer;
  private explainability?: ExplainabilityLayer;

  // Core services
  private modelService: ModelService;
  private taskDecomposer: TaskDecomposer;
  private chainOrchestrator: PromptChainOrchestrator;

  constructor(config: TakossConfig) {
    this.config = config;
    this.prisma = new PrismaClient();

    const claudeKey = config.apiKeys?.claude || process.env.CLAUDE_API_KEY;

    // Initialize Phase 2: Analysis
    this.requirementsAnalyzer = new RequirementsAnalyzer(claudeKey);
    this.dependencyResolver = new DependencyResolver();
    this.complexityEstimator = new ComplexityEstimator();

    // Initialize Phase 3: Frontend
    this.componentDecomposer = new ComponentDecomposer(claudeKey);
    this.componentBuilder = new SequentialComponentBuilder(config.workingDirectory, claudeKey);
    this.integrationGenerator = new IntegrationPromptGenerator(claudeKey);

    // Initialize Phase 4: Backend
    this.apiDecomposer = new APIEndpointDecomposer(claudeKey);
    this.middlewareBuilder = new MiddlewareChainBuilder(claudeKey);
    this.schemaEvolution = new DatabaseSchemaEvolution(claudeKey);

    // Initialize Phase 5: Validation
    this.validator = new CodeValidator();
    this.adaptiveRefinement = new AdaptivePromptRefinement(claudeKey);
    this.selfCorrectingLoop = new SelfCorrectingLoop(claudeKey);
    if (config.socketIO) {
      this.humanInTheLoop = new HumanInTheLoop(config.socketIO);
    }

    // Initialize Phase 6: Deployment
    this.deploymentDecomposer = new DeploymentTaskDecomposer(claudeKey);
    this.infrastructureProvisioner = new InfrastructureProvisioner(
      config.apiKeys?.railway,
      config.apiKeys?.vercel
    );

    // Initialize Phase 7: Modifications
    this.modificationDecomposer = new ModificationRequestDecomposer(claudeKey);
    this.updateGenerator = new IncrementalUpdateGenerator(
      config.workingDirectory,
      claudeKey
    );

    // Initialize Phase 8: Meta-Learning (optional)
    if (config.enableMetaLearning !== false) {
      this.performanceTracker = new PromptPerformanceTracker();
      this.templateEvolution = new PromptTemplateEvolution(claudeKey);
      this.fewShotDB = new FewShotLearningDatabase(claudeKey);
    }

    // Initialize Phase 9: Visualization (optional)
    if (config.enableVisualization !== false) {
      this.visualizer = new PromptChainVisualizer();
      this.explainability = new ExplainabilityLayer(claudeKey);
    }

    // Initialize Core Services
    this.modelService = new ModelService(claudeKey);
    this.taskDecomposer = new TaskDecomposer(claudeKey);
    this.chainOrchestrator = new PromptChainOrchestrator(claudeKey);
  }

  /**
   * Main workflow: Generate a complete full-stack application
   */
  public async generateFullStackApplication(
    request: ProjectGenerationRequest
  ): Promise<ProjectGenerationResult> {
    const projectId = `proj-${Date.now()}`;
    const errors: string[] = [];
    const warnings: string[] = [];
    const artifacts: ProjectGenerationResult['artifacts'] = {};

    console.log(`\nüöÄ Starting Takoss Full-Stack Generation: ${request.projectName}`);
    console.log(`Project ID: ${projectId}\n`);

    try {
      // ==================== PHASE 1: ANALYSIS ====================
      console.log('üìã Phase 1: Requirements Analysis...');

      const analysisResult = await this.requirementsAnalyzer.analyzeRequirements(
        request.requirements
      );

      if (!analysisResult.success) {
        throw new Error('Requirements analysis failed');
      }

      const requirements = analysisResult.requirements;
      console.log(`‚úì Identified ${requirements.entities.length} entities`);
      console.log(`‚úì Identified ${requirements.features.length} features`);

      // Estimate complexity
      const complexity = this.complexityEstimator.estimateRequirementsComplexity(
        requirements
      );
      console.log(`‚úì Complexity Score: ${complexity.totalScore} (${complexity.recommendation})`);

      if (complexity.shouldDecompose) {
        warnings.push('Project complexity is high. Consider breaking into phases.');
      }

      // ==================== PHASE 2: DATABASE SCHEMA ====================
      console.log('\nüóÑÔ∏è  Phase 2: Database Schema Generation...');

      const schemaResult = await this.schemaEvolution.generateSchemaFromEntities(
        requirements.entities
      );

      if (schemaResult.validationErrors.length > 0) {
        console.log('‚ö†Ô∏è  Schema validation issues found, refining...');
        const refinedSchema = await this.schemaEvolution.refineSchema(
          schemaResult.schema,
          schemaResult.validationErrors
        );
        artifacts.database = [refinedSchema.schema];
      } else {
        artifacts.database = [schemaResult.schema];
      }

      console.log(`‚úì Generated Prisma schema with ${requirements.entities.length} models`);

      // ==================== PHASE 3: BACKEND GENERATION ====================
      console.log('\n‚öôÔ∏è  Phase 3: Backend API Generation...');

      // Generate API endpoints
      const apiResult = await this.apiDecomposer.generateEndpointsFromRequirements(
        requirements
      );

      console.log(`‚úì Generated ${apiResult.endpoints.length} API endpoints`);

      // Generate middleware
      const middlewareResult = await this.middlewareBuilder.generateMiddlewareChain({
        enableCORS: true,
        authentication: { type: 'jwt', secret: 'change-me-in-production' },
        enableValidation: true,
        enableLogging: true,
        rateLimiting: { windowMs: 900000, maxRequests: 100 },
      });

      console.log(`‚úì Generated ${middlewareResult.middleware.length} middleware components`);

      artifacts.backend = [
        ...apiResult.endpoints.map((e) => e.route),
        ...middlewareResult.middleware.map((m) => m.name),
      ];

      // ==================== PHASE 4: FRONTEND GENERATION ====================
      console.log('\nüé® Phase 4: Frontend Component Generation...');

      const frontendArtifacts: string[] = [];

      for (const uiReq of requirements.uiRequirements) {
        // Decompose into components
        const components = await this.componentDecomposer.generateComponentsFromRequirement(
          uiReq
        );

        console.log(`‚úì Decomposed "${uiReq.name}" into ${components.components.length} components`);

        // Build components sequentially
        const buildResult = await this.componentBuilder.buildComponentsSequentially(
          components.components,
          { validateEach: true, maxRetries: 3 }
        );

        console.log(`‚úì Built ${buildResult.successful} components successfully`);

        if (buildResult.failed > 0) {
          warnings.push(`${buildResult.failed} components had issues`);
        }

        frontendArtifacts.push(...buildResult.artifacts.map((a) => a.fileName));
      }

      // Generate integration code
      console.log('üîó Generating integration layer...');
      const integrationResult = await this.integrationGenerator.generateFullIntegration(
        requirements
      );

      frontendArtifacts.push(...integrationResult.artifacts.map((a) => a.fileName));
      artifacts.frontend = frontendArtifacts;

      console.log(`‚úì Generated ${integrationResult.artifacts.length} integration files`);

      // ==================== PHASE 5: DEPLOYMENT ====================
      console.log('\nüö¢ Phase 5: Deployment Configuration...');

      const deployConfig = {
        appName: request.projectName,
        platform: request.deploymentPreferences?.frontend || 'vercel',
        buildCommand: 'npm run build',
        startCommand: 'npm start',
        nodeVersion: '18',
        hasDatabase: true,
        databaseType: request.deploymentPreferences?.database || 'postgresql',
        environmentVariables: {
          NODE_ENV: 'production',
          DATABASE_URL: '${DATABASE_URL}',
          CLAUDE_API_KEY: '${CLAUDE_API_KEY}',
        },
      };

      const deployResult = await this.deploymentDecomposer.decomposeDeploymentRequest(
        deployConfig
      );

      console.log(`‚úì Generated ${deployResult.artifacts.length} deployment artifacts`);
      artifacts.deployment = deployResult.artifacts.map((a) => a.fileName);

      // Optional: Auto-deploy if API keys are configured
      if (
        request.targetPlatforms?.includes('auto-deploy') &&
        this.config.apiKeys?.railway &&
        this.config.apiKeys?.vercel
      ) {
        console.log('üåê Auto-deploying to cloud platforms...');

        const deploymentUrls = await this.autoDeployApplication(
          request,
          deployConfig
        );

        return {
          success: true,
          projectId,
          artifacts,
          deploymentUrls,
          errors,
          warnings,
        };
      }

      // ==================== PHASE 6: VISUALIZATION ====================
      if (this.visualizer && this.explainability) {
        console.log('\nüìä Phase 6: Generating Visualizations...');

        // Create visualization of the generation process
        const allTasks = [
          { id: 'analysis', type: 'Analysis', dependencies: [], status: 'completed' },
          { id: 'database', type: 'Database', dependencies: ['analysis'], status: 'completed' },
          { id: 'backend', type: 'Backend', dependencies: ['database'], status: 'completed' },
          { id: 'frontend', type: 'Frontend', dependencies: ['backend'], status: 'completed' },
          { id: 'deployment', type: 'Deployment', dependencies: ['frontend'], status: 'completed' },
        ];

        const visualization = this.visualizer.visualizeExecutionPlan(allTasks);
        const htmlViz = this.visualizer.generateHTMLVisualization(
          visualization,
          `${request.projectName} Generation`
        );

        // Generate explanation
        const explanation = await this.explainability.explainProject({
          name: request.projectName,
          description: request.description,
          features: requirements.features.map((f) => f.name),
          technologies: ['React', 'Node.js', 'Prisma', 'PostgreSQL'],
        });

        console.log('‚úì Generated visualizations and explanations');

        return {
          success: true,
          projectId,
          artifacts,
          visualizations: {
            chainVisualization: htmlViz,
            explanation: JSON.stringify(explanation, null, 2),
          },
          errors,
          warnings,
        };
      }

      console.log('\n‚úÖ Full-stack application generated successfully!');
      console.log(`\nüì¶ Artifacts generated:`);
      console.log(`   - Database: ${artifacts.database?.length || 0} files`);
      console.log(`   - Backend: ${artifacts.backend?.length || 0} files`);
      console.log(`   - Frontend: ${artifacts.frontend?.length || 0} files`);
      console.log(`   - Deployment: ${artifacts.deployment?.length || 0} files`);

      return {
        success: true,
        projectId,
        artifacts,
        errors,
        warnings,
      };
    } catch (error: any) {
      console.error('‚ùå Generation failed:', error.message);
      errors.push(error.message);

      return {
        success: false,
        projectId,
        artifacts,
        errors,
        warnings,
      };
    }
  }

  /**
   * Auto-deploy application to cloud platforms
   */
  private async autoDeployApplication(
    request: ProjectGenerationRequest,
    deployConfig: any
  ): Promise<{ frontend?: string; backend?: string }> {
    const urls: { frontend?: string; backend?: string } = {};

    try {
      // Deploy backend to Railway
      if (this.config.apiKeys?.railway) {
        console.log('üì¶ Deploying backend to Railway...');
        const backendDeploy = await this.infrastructureProvisioner.provisionInfrastructure(
          deployConfig,
          'railway'
        );

        if (backendDeploy.success) {
          urls.backend = backendDeploy.deploymentUrl;
          console.log(`‚úì Backend deployed: ${urls.backend}`);
        }
      }

      // Deploy frontend to Vercel
      if (this.config.apiKeys?.vercel) {
        console.log('üé® Deploying frontend to Vercel...');
        const frontendDeploy = await this.infrastructureProvisioner.provisionInfrastructure(
          deployConfig,
          'vercel'
        );

        if (frontendDeploy.success) {
          urls.frontend = frontendDeploy.deploymentUrl;
          console.log(`‚úì Frontend deployed: ${urls.frontend}`);
        }
      }
    } catch (error: any) {
      console.error('‚ö†Ô∏è  Deployment warning:', error.message);
    }

    return urls;
  }

  /**
   * Modify existing application
   */
  public async modifyApplication(
    modificationRequest: string,
    codebaseContext: Map<string, string>
  ): Promise<{
    success: boolean;
    results: any[];
    rollbackPoint?: any;
  }> {
    console.log('\nüîß Starting Application Modification...');

    const request = {
      id: `mod-${Date.now()}`,
      description: modificationRequest,
      priority: 'medium' as const,
      category: 'enhancement' as const,
    };

    // Analyze modification
    const plan = await this.modificationDecomposer.analyzeModificationRequest(
      request,
      codebaseContext
    );

    console.log(`‚úì Created modification plan with ${plan.tasks.length} tasks`);

    if (plan.warnings.length > 0) {
      console.log('‚ö†Ô∏è  Warnings:');
      plan.warnings.forEach((w) => console.log(`   - ${w}`));
    }

    // Execute modification
    const result = await this.updateGenerator.executeModificationPlan(plan, {
      createBranch: true,
      validateAfterEach: true,
      commitAfterEach: false,
    });

    console.log(`‚úì Completed ${result.results.filter((r) => r.success).length}/${result.results.length} tasks`);

    return result;
  }

  /**
   * Run meta-learning evolution cycle
   */
  public async runMetaLearningCycle(): Promise<void> {
    if (!this.templateEvolution || !this.performanceTracker) {
      console.log('‚ö†Ô∏è  Meta-learning not enabled');
      return;
    }

    console.log('\nüß† Running Meta-Learning Evolution Cycle...');

    const evolutionResult = await this.templateEvolution.runEvolutionCycle(0.7);

    console.log(`‚úì Analyzed: ${evolutionResult.analyzed} templates`);
    console.log(`‚úì Improved: ${evolutionResult.improved} templates`);
    console.log(`‚úì Testing: ${evolutionResult.tested} variations`);

    evolutionResult.details.forEach((detail) => {
      console.log(`   - ${detail}`);
    });
  }

  /**
   * Get performance dashboard
   */
  public async getPerformanceDashboard(): Promise<any> {
    if (!this.performanceTracker) {
      throw new Error('Performance tracking not enabled');
    }

    return await this.performanceTracker.getDashboardData();
  }

  /**
   * Explain a technical concept
   */
  public async explainConcept(
    concept: string,
    context?: string
  ): Promise<any> {
    if (!this.explainability) {
      throw new Error('Explainability layer not enabled');
    }

    return await this.explainability.answerQuestion(concept, context || '');
  }

  /**
   * Cleanup resources
   */
  public async close(): Promise<void> {
    await this.prisma.$disconnect();

    if (this.performanceTracker) {
      await this.performanceTracker.close();
    }

    if (this.templateEvolution) {
      await this.templateEvolution.close();
    }
  }
}
