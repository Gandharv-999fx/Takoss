import * as fs from 'fs/promises';
import * as path from 'path';
import archiver from 'archiver';
import { createWriteStream } from 'fs';

/**
 * ProjectWriter - Writes generated projects to disk and creates downloadable archives
 */

export interface GeneratedProject {
  projectId: string;
  projectName: string;
  files: {
    path: string;
    content: string;
  }[];
  metadata: {
    description: string;
    generatedAt: Date;
    requirements: string;
  };
}

export class ProjectWriter {
  private outputDir: string;

  constructor(outputDir: string = './output/projects') {
    this.outputDir = outputDir;
  }

  /**
   * Write a complete project to disk
   */
  public async writeProject(project: GeneratedProject): Promise<string> {
    const projectPath = path.join(this.outputDir, project.projectId);

    // Create project directory
    await fs.mkdir(projectPath, { recursive: true });

    // Write all files
    for (const file of project.files) {
      const filePath = path.join(projectPath, file.path);
      const fileDir = path.dirname(filePath);

      // Create parent directories
      await fs.mkdir(fileDir, { recursive: true });

      // Write file
      await fs.writeFile(filePath, file.content, 'utf-8');
    }

    // Write project metadata
    await this.writeMetadata(projectPath, project);

    // Create README
    await this.createReadme(projectPath, project);

    return projectPath;
  }

  /**
   * Write project metadata
   */
  private async writeMetadata(projectPath: string, project: GeneratedProject): Promise<void> {
    const metadata = {
      projectId: project.projectId,
      projectName: project.projectName,
      description: project.metadata.description,
      requirements: project.metadata.requirements,
      generatedAt: project.metadata.generatedAt.toISOString(),
      files: project.files.map((f) => f.path),
      generatedBy: 'Takoss AI Application Builder',
    };

    await fs.writeFile(
      path.join(projectPath, 'takoss.json'),
      JSON.stringify(metadata, null, 2),
      'utf-8'
    );
  }

  /**
   * Create project README
   */
  private async createReadme(projectPath: string, project: GeneratedProject): Promise<void> {
    const readme = `# ${project.projectName}

${project.metadata.description}

## Generated by Takoss

This project was automatically generated by Takoss AI Application Builder.

**Generated:** ${project.metadata.generatedAt.toLocaleString()}
**Project ID:** ${project.projectId}

## Requirements

Original requirements:
\`\`\`
${project.metadata.requirements}
\`\`\`

## Getting Started

### Prerequisites
- Node.js 18+
- npm or yarn
- PostgreSQL (for backend)

### Installation

\`\`\`bash
# Install dependencies
npm install

# Set up environment variables
cp .env.example .env
# Edit .env with your values

# Run database migrations (if backend exists)
npx prisma migrate dev

# Start development server
npm run dev
\`\`\`

### Project Structure

\`\`\`
${this.generateFileTree(project.files)}
\`\`\`

## Features

This application includes:
- Generated React components with TypeScript
- RESTful API with Express.js
- Database integration with Prisma
- Authentication and authorization
- Deployment configurations

## Deployment

See deployment files for instructions on deploying to:
- Docker
- Vercel (frontend)
- Railway (backend)

## Support

Generated with ❤️ by Takoss
`;

    await fs.writeFile(path.join(projectPath, 'README.md'), readme, 'utf-8');
  }

  /**
   * Generate file tree representation
   */
  private generateFileTree(files: { path: string }[]): string {
    const tree: string[] = [];
    const sorted = files.map((f) => f.path).sort();

    sorted.forEach((filePath) => {
      const depth = filePath.split('/').length - 1;
      const indent = '  '.repeat(depth);
      const fileName = path.basename(filePath);
      tree.push(`${indent}├── ${fileName}`);
    });

    return tree.join('\n');
  }

  /**
   * Create zip archive of project
   */
  public async createZipArchive(projectId: string): Promise<string> {
    const projectPath = path.join(this.outputDir, projectId);
    const zipPath = path.join(this.outputDir, `${projectId}.zip`);

    return new Promise((resolve, reject) => {
      const output = createWriteStream(zipPath);
      const archive = archiver('zip', { zlib: { level: 9 } });

      output.on('close', () => {
        console.log(`✅ Created zip: ${archive.pointer()} bytes`);
        resolve(zipPath);
      });

      archive.on('error', (err) => {
        reject(err);
      });

      archive.pipe(output);
      archive.directory(projectPath, false);
      archive.finalize();
    });
  }

  /**
   * Get project file structure
   */
  public async getProjectStructure(projectId: string): Promise<any> {
    const projectPath = path.join(this.outputDir, projectId);

    try {
      const metadata = await fs.readFile(
        path.join(projectPath, 'takoss.json'),
        'utf-8'
      );
      return JSON.parse(metadata);
    } catch (error) {
      return null;
    }
  }

  /**
   * Read a specific file from project
   */
  public async readProjectFile(projectId: string, filePath: string): Promise<string | null> {
    const fullPath = path.join(this.outputDir, projectId, filePath);

    try {
      return await fs.readFile(fullPath, 'utf-8');
    } catch (error) {
      return null;
    }
  }

  /**
   * List all projects
   */
  public async listProjects(): Promise<any[]> {
    try {
      await fs.mkdir(this.outputDir, { recursive: true });
      const entries = await fs.readdir(this.outputDir, { withFileTypes: true });

      const projects = [];
      for (const entry of entries) {
        if (entry.isDirectory()) {
          const metadata = await this.getProjectStructure(entry.name);
          if (metadata) {
            projects.push(metadata);
          }
        }
      }

      return projects.sort((a, b) =>
        new Date(b.generatedAt).getTime() - new Date(a.generatedAt).getTime()
      );
    } catch (error) {
      return [];
    }
  }

  /**
   * Delete a project
   */
  public async deleteProject(projectId: string): Promise<boolean> {
    const projectPath = path.join(this.outputDir, projectId);
    const zipPath = path.join(this.outputDir, `${projectId}.zip`);

    try {
      // Delete directory
      await fs.rm(projectPath, { recursive: true, force: true });

      // Delete zip if exists
      try {
        await fs.unlink(zipPath);
      } catch (e) {
        // Zip might not exist
      }

      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Convert generation result to project format
   */
  public convertGenerationToProject(
    projectId: string,
    projectName: string,
    description: string,
    requirements: string,
    result: any
  ): GeneratedProject {
    const files: { path: string; content: string }[] = [];

    // Add frontend files
    if (result.phases?.frontend) {
      // Placeholder - actual implementation would extract from result
      files.push({
        path: 'frontend/src/App.tsx',
        content: '// Generated React App\nexport default function App() { return <div>Hello</div>; }',
      });
      files.push({
        path: 'frontend/package.json',
        content: JSON.stringify({
          name: projectName + '-frontend',
          version: '1.0.0',
          dependencies: { react: '^18.0.0', 'react-dom': '^18.0.0' },
        }, null, 2),
      });
    }

    // Add backend files
    if (result.phases?.backend) {
      files.push({
        path: 'backend/src/server.ts',
        content: '// Generated Express Server\nimport express from "express";\nconst app = express();',
      });
      files.push({
        path: 'backend/package.json',
        content: JSON.stringify({
          name: projectName + '-backend',
          version: '1.0.0',
          dependencies: { express: '^4.18.0', '@prisma/client': '^5.0.0' },
        }, null, 2),
      });
    }

    // Add database schema
    if (result.phases?.database) {
      files.push({
        path: 'prisma/schema.prisma',
        content: result.phases.database.schema || '// Generated Prisma Schema',
      });
    }

    // Add deployment files
    if (result.phases?.deployment) {
      files.push({
        path: 'Dockerfile',
        content: '# Generated Dockerfile\nFROM node:18-alpine\nWORKDIR /app\nCOPY . .\nRUN npm install\nCMD ["npm", "start"]',
      });
      files.push({
        path: '.dockerignore',
        content: 'node_modules\n.git\n.env\ndist',
      });
    }

    // Add environment template
    files.push({
      path: '.env.example',
      content: `DATABASE_URL="postgresql://user:pass@localhost:5432/${projectName}"
CLAUDE_API_KEY="your-api-key"
NODE_ENV="development"`,
    });

    return {
      projectId,
      projectName,
      files,
      metadata: {
        description,
        generatedAt: new Date(),
        requirements,
      },
    };
  }
}
