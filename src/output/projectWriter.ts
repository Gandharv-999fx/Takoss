import * as fs from 'fs/promises';
import * as path from 'path';
import archiver from 'archiver';
import { createWriteStream } from 'fs';

/**
 * ProjectWriter - Writes generated projects to disk and creates downloadable archives
 */

export interface GeneratedProject {
  projectId: string;
  projectName: string;
  files: {
    path: string;
    content: string;
  }[];
  metadata: {
    description: string;
    generatedAt: Date;
    requirements: string;
  };
}

export class ProjectWriter {
  private outputDir: string;

  constructor(outputDir: string = './output/projects') {
    this.outputDir = outputDir;
  }

  /**
   * Write a complete project to disk
   */
  public async writeProject(project: GeneratedProject): Promise<string> {
    const projectPath = path.join(this.outputDir, project.projectId);

    // Create project directory
    await fs.mkdir(projectPath, { recursive: true });

    // Write all files
    for (const file of project.files) {
      const filePath = path.join(projectPath, file.path);
      const fileDir = path.dirname(filePath);

      // Create parent directories
      await fs.mkdir(fileDir, { recursive: true });

      // Write file
      await fs.writeFile(filePath, file.content, 'utf-8');
    }

    // Write project metadata
    await this.writeMetadata(projectPath, project);

    // Create README
    await this.createReadme(projectPath, project);

    return projectPath;
  }

  /**
   * Write project metadata
   */
  private async writeMetadata(projectPath: string, project: GeneratedProject): Promise<void> {
    const metadata = {
      projectId: project.projectId,
      projectName: project.projectName,
      description: project.metadata.description,
      requirements: project.metadata.requirements,
      generatedAt: project.metadata.generatedAt.toISOString(),
      files: project.files.map((f) => f.path),
      generatedBy: 'Takoss AI Application Builder',
    };

    await fs.writeFile(
      path.join(projectPath, 'takoss.json'),
      JSON.stringify(metadata, null, 2),
      'utf-8'
    );
  }

  /**
   * Create project README
   */
  private async createReadme(projectPath: string, project: GeneratedProject): Promise<void> {
    const readme = `# ${project.projectName}

${project.metadata.description}

## Generated by Takoss

This project was automatically generated by Takoss AI Application Builder.

**Generated:** ${project.metadata.generatedAt.toLocaleString()}
**Project ID:** ${project.projectId}

## Requirements

Original requirements:
\`\`\`
${project.metadata.requirements}
\`\`\`

## Getting Started

### Prerequisites
- Node.js 18+
- npm or yarn
- PostgreSQL (for backend)

### Installation

\`\`\`bash
# Install dependencies
npm install

# Set up environment variables
cp .env.example .env
# Edit .env with your values

# Run database migrations (if backend exists)
npx prisma migrate dev

# Start development server
npm run dev
\`\`\`

### Project Structure

\`\`\`
${this.generateFileTree(project.files)}
\`\`\`

## Features

This application includes:
- Generated React components with TypeScript
- RESTful API with Express.js
- Database integration with Prisma
- Authentication and authorization
- Deployment configurations

## Deployment

See deployment files for instructions on deploying to:
- Docker
- Vercel (frontend)
- Railway (backend)

## Support

Generated with â¤ï¸ by Takoss
`;

    await fs.writeFile(path.join(projectPath, 'README.md'), readme, 'utf-8');
  }

  /**
   * Generate file tree representation
   */
  private generateFileTree(files: { path: string }[]): string {
    const tree: string[] = [];
    const sorted = files.map((f) => f.path).sort();

    sorted.forEach((filePath) => {
      const depth = filePath.split('/').length - 1;
      const indent = '  '.repeat(depth);
      const fileName = path.basename(filePath);
      tree.push(`${indent}â”œâ”€â”€ ${fileName}`);
    });

    return tree.join('\n');
  }

  /**
   * Create zip archive of project
   */
  public async createZipArchive(projectId: string): Promise<string> {
    const projectPath = path.join(this.outputDir, projectId);
    const zipPath = path.join(this.outputDir, `${projectId}.zip`);

    return new Promise((resolve, reject) => {
      const output = createWriteStream(zipPath);
      const archive = archiver('zip', { zlib: { level: 9 } });

      output.on('close', () => {
        console.log(`âœ… Created zip: ${archive.pointer()} bytes`);
        resolve(zipPath);
      });

      archive.on('error', (err) => {
        reject(err);
      });

      archive.pipe(output);
      archive.directory(projectPath, false);
      archive.finalize();
    });
  }

  /**
   * Get project file structure
   */
  public async getProjectStructure(projectId: string): Promise<any> {
    const projectPath = path.join(this.outputDir, projectId);

    try {
      const metadata = await fs.readFile(
        path.join(projectPath, 'takoss.json'),
        'utf-8'
      );
      return JSON.parse(metadata);
    } catch (error) {
      return null;
    }
  }

  /**
   * Read a specific file from project
   */
  public async readProjectFile(projectId: string, filePath: string): Promise<string | null> {
    const fullPath = path.join(this.outputDir, projectId, filePath);

    try {
      return await fs.readFile(fullPath, 'utf-8');
    } catch (error) {
      return null;
    }
  }

  /**
   * List all projects
   */
  public async listProjects(): Promise<any[]> {
    try {
      await fs.mkdir(this.outputDir, { recursive: true });
      const entries = await fs.readdir(this.outputDir, { withFileTypes: true });

      const projects = [];
      for (const entry of entries) {
        if (entry.isDirectory()) {
          const metadata = await this.getProjectStructure(entry.name);
          if (metadata) {
            projects.push(metadata);
          }
        }
      }

      return projects.sort((a, b) =>
        new Date(b.generatedAt).getTime() - new Date(a.generatedAt).getTime()
      );
    } catch (error) {
      return [];
    }
  }

  /**
   * Delete a project
   */
  public async deleteProject(projectId: string): Promise<boolean> {
    const projectPath = path.join(this.outputDir, projectId);
    const zipPath = path.join(this.outputDir, `${projectId}.zip`);

    try {
      // Delete directory
      await fs.rm(projectPath, { recursive: true, force: true });

      // Delete zip if exists
      try {
        await fs.unlink(zipPath);
      } catch (e) {
        // Zip might not exist
      }

      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Convert generation result to project format
   */
  public convertGenerationToProject(
    projectId: string,
    projectName: string,
    description: string,
    requirements: string,
    result: any
  ): GeneratedProject {
    const files: { path: string; content: string }[] = [];

    // Add frontend files - USE ACTUAL GENERATED CODE
    if (result.phases?.frontend?.components && result.phases.frontend.components.length > 0) {
      // Add each generated component
      result.phases.frontend.components.forEach((component: any) => {
        files.push({
          path: `frontend/src/components/${component.fileName}`,
          content: component.code,
        });
      });

      // Generate main App.tsx that imports all components
      const componentImports = result.phases.frontend.components
        .map((c: any) => {
          const componentName = c.name;
          const fileName = c.fileName.replace(/\.tsx?$/, '');
          return `import ${componentName} from './components/${fileName}';`;
        })
        .join('\n');

      const componentUsage = result.phases.frontend.components
        .map((c: any) => `      <${c.name} />`)
        .join('\n');

      files.push({
        path: 'frontend/src/App.tsx',
        content: `import React from 'react';
${componentImports}

function App() {
  return (
    <div className="min-h-screen bg-gray-50">
${componentUsage}
    </div>
  );
}

export default App;
`,
      });

      // Generate package.json with necessary dependencies
      files.push({
        path: 'frontend/package.json',
        content: JSON.stringify({
          name: projectName + '-frontend',
          version: '1.0.0',
          type: 'module',
          scripts: {
            dev: 'vite',
            build: 'tsc && vite build',
            preview: 'vite preview',
          },
          dependencies: {
            react: '^18.2.0',
            'react-dom': '^18.2.0',
          },
          devDependencies: {
            '@types/react': '^18.2.0',
            '@types/react-dom': '^18.2.0',
            '@vitejs/plugin-react': '^4.0.0',
            autoprefixer: '^10.4.14',
            postcss: '^8.4.24',
            tailwindcss: '^3.3.2',
            typescript: '^5.0.0',
            vite: '^4.3.9',
          },
        }, null, 2),
      });

      // Generate Vite config
      files.push({
        path: 'frontend/vite.config.ts',
        content: `import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      '/api': 'http://localhost:3000',
    },
  },
});
`,
      });

      // Generate tsconfig.json
      files.push({
        path: 'frontend/tsconfig.json',
        content: JSON.stringify({
          compilerOptions: {
            target: 'ES2020',
            useDefineForClassFields: true,
            lib: ['ES2020', 'DOM', 'DOM.Iterable'],
            module: 'ESNext',
            skipLibCheck: true,
            moduleResolution: 'bundler',
            allowImportingTsExtensions: true,
            resolveJsonModule: true,
            isolatedModules: true,
            noEmit: true,
            jsx: 'react-jsx',
            strict: true,
            noUnusedLocals: true,
            noUnusedParameters: true,
            noFallthroughCasesInSwitch: true,
          },
          include: ['src'],
        }, null, 2),
      });

      // Generate tsconfig.node.json for Vite config
      files.push({
        path: 'frontend/tsconfig.node.json',
        content: JSON.stringify({
          compilerOptions: {
            composite: true,
            skipLibCheck: true,
            module: 'ESNext',
            moduleResolution: 'bundler',
            allowSyntheticDefaultImports: true,
          },
          include: ['vite.config.ts'],
        }, null, 2),
      });

      // Generate Tailwind config
      files.push({
        path: 'frontend/tailwind.config.js',
        content: `/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
`,
      });

      // Generate index.html
      files.push({
        path: 'frontend/index.html',
        content: `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>${projectName}</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
`,
      });

      // Generate main.tsx
      files.push({
        path: 'frontend/src/main.tsx',
        content: `import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
`,
      });

      // Generate index.css with Tailwind directives
      files.push({
        path: 'frontend/src/index.css',
        content: `@tailwind base;
@tailwind components;
@tailwind utilities;
`,
      });
    }

    // Add backend files - USE ACTUAL GENERATED CODE
    if (result.phases?.backend?.routes && result.phases.backend.routes.length > 0) {
      // Add each generated route
      result.phases.backend.routes.forEach((route: any) => {
        files.push({
          path: `backend/src/routes${route.path}`,
          content: route.code,
        });
      });

      // Generate server.ts that imports all routes
      const routeImports = result.phases.backend.routes
        .map((r: any, idx: number) => `import route${idx} from './routes${r.path.replace(/\.ts$/, '')}';`)
        .join('\n');

      files.push({
        path: 'backend/src/server.ts',
        content: `import express from 'express';
import cors from 'cors';
${routeImports}

const app = express();
const PORT = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());

// Routes
${result.phases.backend.routes.map((r: any, idx: number) => `app.use('/api', route${idx});`).join('\n')}

app.listen(PORT, () => {
  console.log(\`ðŸš€ Server running on port \${PORT}\`);
});
`,
      });

      files.push({
        path: 'backend/package.json',
        content: JSON.stringify({
          name: projectName + '-backend',
          version: '1.0.0',
          scripts: {
            dev: 'ts-node src/server.ts',
            build: 'tsc',
            start: 'node dist/server.js',
          },
          dependencies: {
            express: '^4.18.2',
            '@prisma/client': '^5.0.0',
            cors: '^2.8.5',
          },
          devDependencies: {
            '@types/express': '^4.17.17',
            '@types/cors': '^2.8.13',
            '@types/node': '^20.3.1',
            'ts-node': '^10.9.1',
            typescript: '^5.1.3',
          },
        }, null, 2),
      });

      files.push({
        path: 'backend/tsconfig.json',
        content: JSON.stringify({
          compilerOptions: {
            target: 'ES2020',
            module: 'commonjs',
            lib: ['ES2020'],
            outDir: './dist',
            rootDir: './src',
            strict: true,
            esModuleInterop: true,
            skipLibCheck: true,
            forceConsistentCasingInFileNames: true,
          },
          include: ['src/**/*'],
          exclude: ['node_modules'],
        }, null, 2),
      });
    }

    // Add database schema - USE ACTUAL GENERATED SCHEMA
    if (result.phases?.database?.schema) {
      files.push({
        path: 'prisma/schema.prisma',
        content: result.phases.database.schema,
      });
    }

    // Add deployment files - USE ACTUAL GENERATED CONFIGS
    if (result.phases?.deployment) {
      if (result.phases.deployment.dockerFile) {
        files.push({
          path: 'Dockerfile',
          content: result.phases.deployment.dockerFile,
        });
      }

      if (result.phases.deployment.dockerCompose) {
        files.push({
          path: 'docker-compose.yml',
          content: result.phases.deployment.dockerCompose,
        });
      }

      if (result.phases.deployment.dockerIgnore) {
        files.push({
          path: '.dockerignore',
          content: result.phases.deployment.dockerIgnore,
        });
      }
    }

    // Add environment template
    files.push({
      path: '.env.example',
      content: `DATABASE_URL="postgresql://user:pass@localhost:5432/${projectName}"
CLAUDE_API_KEY="your-api-key"
NODE_ENV="development"
PORT="3000"`,
    });

    // Add root package.json for monorepo structure
    files.push({
      path: 'package.json',
      content: JSON.stringify({
        name: projectName,
        version: '1.0.0',
        private: true,
        workspaces: ['frontend', 'backend'],
        scripts: {
          'dev:frontend': 'npm run dev --workspace=frontend',
          'dev:backend': 'npm run dev --workspace=backend',
          'build:frontend': 'npm run build --workspace=frontend',
          'build:backend': 'npm run build --workspace=backend',
          'build': 'npm run build:frontend && npm run build:backend',
        },
      }, null, 2),
    });

    return {
      projectId,
      projectName,
      files,
      metadata: {
        description,
        generatedAt: new Date(),
        requirements,
      },
    };
  }
}
